# Vuex

## Vuex Basic

### Vuex란?

#### 개념

Vuex는 Vue.js 애플리케이션에 대한 **상태 관리 패턴** + **라이브러리**입니다. 애플리케이션의 모든 컴포넌트에 대한 `중앙 집중식 저장소 역할`을 하며 예측 가능한 방식으로 **상태를 변경**할 수 있습니다. 또한 Vue의 공식 devtools 확장 프로그램과 통합되어 설정 시간이 필요 없는 디버깅 및 상태 스냅 샷 **내보내기/가져오기**와 같은 고급 기능을 제공합니다.

- 상태 관리 패턴이란 무엇인가?
  
  - `상태`는 앱을 작동시키는 원본 소스입니다.
  
  - `뷰`는 이 상태의 선언적 매핑입니다.
  
  - `액션`은 뷰에서 사용자 입력에 대해 반응적으로 상태를 바꾸는 방법입니다.

```JS
new Vue({
    // 상태
    data() {
        return {
            count: 0
        }
    },
    // 뷰
    template: `
    <div>{{ count }} </div>
    `,
    // 액션
    methods: {
        increment() { 
            this.count++;
        }
    }
})
```

<br />

그러나 공통의 상태를 공유하는 여러 컴포넌트가 있는 경우 단순함이 빠르게 저하됩니다.

 1. 여러 뷰는 같은 상태에 의존합니다.
 2. 서로 다른 뷰의 작업은 동일한 상태를 반영해야 할 수 있습니다.

![Vuex](https://v3.vuex.vuejs.org/vuex.png)

첫번째 문제의 경우, **지나치게 중첩된 컴포넌트**를 통과하는 **prop**은 장황할 수 있으며 형제 컴포넌트에서는 작동하지 않습니다.

두번째 문제의 경우, **직접 부모/자식 인스턴스를 참조**하거나 **이벤트**를 통해 상태의 여러 복사본을 변경 및 동기화하려는 등의 해결 방법을 사용해야 합니다. 이러한 패턴을 모두 불안정하고 유지보수가 불가능한 코드로 빠르게 변경됩니다.

그렇다면 컴포넌트에서 공유된 상태를 추출하고 이를 전역 싱글톤(Singleton)으로 관리해야 합니다. 이를 통해 우리의 컴포넌트 트리는 커다란 `뷰`가 되며 모든 컴포넌트는 트리에 상관없이 액세스하거나 동작을 트리거 할 수 있습니다! 또한 상태 관리 및 특정 규칙 적용과 관련된 개념을 정의하고 분리함으로써 코드의 구조와 유지 관리 기능을 향상시킵니다.

<br />

 - 언제 사용해야 하나요??
   
   - **Learning Curve** : `Vuex`는 공유된 상태 관리를 처리하는 데 유용하지만, 개념에 대한 이해와 시작하는 비용도 함께 듭니다.
   
   - **Opportunity Cost** : 단기간과 장기간 생산성 간의 기회 비용이 있습니다.

대규모 SPA 를 구축하지 않고 Vuex로 바로 뛰어 들었다면, 시간이 오래 걸리고 힘든 일일 것입니다. **앱이 단순하다면** Vuex 없이 충분합니다. 간단한 글로벌 이벤트 버스만 있으면 됩니다.

그러나 중대형 규모의 SPA를 구축하는 경우 Vue 컴포넌트 외부의 상태를 보다 잘 처리할 수 있는 방법을 생각하게 될 가능성이 있습니다. 결국 Vuex는 자연스럽게 선택할 수 있는 단계가 될 수도 있습니다.

<br />

#### 설치

**직접 다운로드/CDN**

Unpkg.com은 NPM 기반 CDN 링크를 제공합니다. 이 링크는 항상 NPM의 최신 릴리즈를 가리킵니다. https://unpkg.com/vuex@2.0.0과 같은 URL을 통해 특정 버전/태그를 사용할 수도 있습니다.

Vue 뒤에 vuex를 추가하면 자동으로 설치(추가) 됩니다.

```HTML
<script src="/path/to/vue.js"></script>
<script src="/path/to/vuex.js"></script>

<script>
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)
</script>
```

**NPM**
```SHELL
npm install vuex --save
```

**YARN**
```SHELL
yarn add vuex
```

<br />

#### 시작하기

모든 Vuex 애플리케이션의 중심에는 `store`가 있습니다. `store`는 기본적으로 애플리케이션 상태를 보유하고 있는 컨테이너입니다. `Vuex`  저장소가 일반 전역 개체와 두 가지 다른 점이 있습니다. 

 1. Vuex store는 반응형입니다. Vue 컴포넌트 상태를 검색할 때 저장소의 상태가 변경되면 효율적으로 대응하고 업데이트 합니다.
 2. 저장소의 상태를 직접 변경할 수 없습니다. 저장소의 상태를 변경하는 유일한 방법은 명시적인 **커밋**(commit)을 이용한 **변이(mutation)**입니다. 이렇게 하면 모든 상태에 대한 추적이 가능한 기록이 남을 수 있으며 툴을 사용하여 앱을 더 잘 이해할 수 있습니다.


**가장 단순한 저장소**

`state`객체에 **store.state**로 접근하여 `store.commit` 메소드로 상태 변경을 트리거할 수 있습니다.

다시 말해, "store.state.count"를 **직접 변경**하는 대신 `변이를 수행하는 이유`는 명시적으로 **추적**을 하기 때문입니다. 이 간단한 규칙에 따라 의도를 보다 명확하게 표현할 수 있으므로 코드를 읽을 때 상태 변화를 더 잘 지켜볼 수 있습니다. 또한, Vue Devtools 모든 변이를 기록하고 상태 스냅샷을 저장하거나 시간 흐름에 따라 디버깅을 할 수 있는 도구를 제공합니다.

컴포넌트 안에서 **store state를 사용**하는 것은 단순히 계산된 속성 내에서 상태를 반환하는 것입니다. 변경을 트리거 하는 것은 컴포넌트 메소드에서 변경을 커밋하는 것을 의미합니다.

```JS
// 모듈 시스템을 사용하는 경우 Vue.use(Vuex)를 먼저 호출해야합니다.

const store = new Vuex.Store({
    state: {
        count: 0
    },
    mutations: {
        increment(state) {
            state.count++;
        }
    }
})

store.commit('increment')

console.log(store.state.count)  // 1
```